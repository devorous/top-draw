import { parseGbr, parseGih } from './utils/parseGimp.js';

/**
 * Brush Gallery - loads and displays GIMP brushes from the brushes folder
 *
 * Brushes are loaded from a manifest file (brushes/manifest.json) which is
 * generated by running: node scripts/generate-brush-manifest.js
 */
export class BrushGallery {
  constructor(options = {}) {
    this.brushListEl = null;
    this.galleryEl = null;
    this.brushes = [];
    this.selectedBrush = null;
    this.onSelect = options.onSelect || (() => {});
    this.manifestPath = 'brushes/manifest.json';
  }

  init() {
    this.galleryEl = document.getElementById('brushGallery');
    this.brushListEl = document.getElementById('brushList');

    if (!this.brushListEl) {
      console.warn('Brush gallery elements not found');
      return;
    }

    this.loadBrushes();
  }

  async loadBrushes() {
    try {
      // Fetch the manifest
      const response = await fetch(this.manifestPath);
      if (!response.ok) {
        console.warn('Brush manifest not found. Run: node scripts/generate-brush-manifest.js');
        return;
      }

      const manifest = await response.json();

      // Load each brush from the manifest
      for (const entry of manifest.brushes) {
        try {
          const brush = await this.loadBrush(`brushes/${entry.file}`);
          if (brush) {
            this.brushes.push(brush);
            this.addBrushToGallery(brush);
          }
        } catch (err) {
          console.warn(`Failed to load brush: ${entry.file}`, err);
        }
      }
    } catch (err) {
      console.warn('Failed to load brush manifest:', err);
    }
  }

  async loadBrush(filePath) {
    const response = await fetch(filePath);
    if (!response.ok) {
      throw new Error(`Failed to fetch ${filePath}`);
    }

    const arrayBuffer = await response.arrayBuffer();
    const fileName = filePath.split('/').pop();
    const fileType = fileName.split('.').pop().toLowerCase();

    let brushData = null;

    if (fileType === 'gbr') {
      brushData = parseGbr(arrayBuffer);
      if (brushData) {
        brushData.type = 'gbr';
        brushData.fileName = fileName;
        // Create image element for the brush
        const image = new Image();
        image.src = brushData.gimpUrl;
        brushData.image = image;
      }
    } else if (fileType === 'gih') {
      brushData = parseGih(arrayBuffer);
      if (brushData) {
        brushData.type = 'gih';
        brushData.fileName = fileName;
        // Create images for all brush cells
        const images = brushData.gBrushes.map(brush => {
          const img = new Image();
          img.src = brush.gimpUrl;
          return img;
        });
        brushData.images = images;
      }
    }

    return brushData;
  }

  addBrushToGallery(brush) {
    const item = document.createElement('div');
    item.className = 'brushItem';
    item.title = brush.brushName || brush.name || brush.fileName;

    const img = document.createElement('img');
    // Use the first brush image as thumbnail
    if (brush.type === 'gih' && brush.gBrushes && brush.gBrushes.length > 0) {
      img.src = brush.gBrushes[0].gimpUrl;
    } else {
      img.src = brush.gimpUrl;
    }
    img.alt = brush.brushName || brush.name || 'Brush';

    item.appendChild(img);

    item.addEventListener('click', () => {
      this.selectBrush(brush, item);
    });

    this.brushListEl.appendChild(item);
  }

  selectBrush(brush, itemEl) {
    // Remove selection from previous
    const prevSelected = this.brushListEl.querySelector('.brushItem.selected');
    if (prevSelected) {
      prevSelected.classList.remove('selected');
    }

    // Select new brush
    itemEl.classList.add('selected');
    this.selectedBrush = brush;

    // Notify callback
    this.onSelect(brush);
  }

  show() {
    if (this.galleryEl) {
      this.galleryEl.style.display = 'block';
    }
  }

  hide() {
    if (this.galleryEl) {
      this.galleryEl.style.display = 'none';
    }
  }

  getSelectedBrush() {
    return this.selectedBrush;
  }
}
